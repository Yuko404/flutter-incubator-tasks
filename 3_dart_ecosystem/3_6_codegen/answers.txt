1. What is code generation? Which problems does it solve and how?
Кодогенерация - это процесс, в ходе которого одна программа пишет код для другой программы. В Dart кодогенерация используется для того, чтобы
избавить разработчика от написания скучного и однотипного кода (boilerplate-код) (в котором ещё легко ошибиться и потратить кучу времени на 
поиск ошибки), чтобы он смог сосредоточится на творческих и интересных задачах. Обычно кодогенерация используется для написания чего-то в роде
сериализации, hashCode, == и др. В целом, такой код является однотипным и не представляет трудности в написании даже другой программе 
(так как у него нет никакой сложной логики или различных подходов к написанию). Ещё одна важная проблема, которую решает кодогенерация -
отсутствие рефлексии. Из-за того, что Dart использует AOT-компиляцию и Tree-shaking мы не можем гарантировать, что сможем узнать информацию
о том или ином классе или методу во время работы приложения. Поэтому кодогенерация делает это на этапе компиляции, гарантируя, что эта информация
не удалится во время Tree-shaking.

2. How code generations is represented in [Dart]?
Кодогенерация в Dart представлена нескольккими инструментами, а именно build, build_runner, source_gen, analyzer. У каждого из них своя задача, которую нужно
решить. Build - низкоуровневый пакет, который работает с кодом. Он анализирует строки кода и создаёт Builder'ов, которые в свою очередь
будут генерировать код. Build_runner - инструмент, который занимается запуском build'ов, которых создаёт build. Делается это путём регистрации
builder'а в build.yaml. source_gen - надстройка над build, которая является более высокоуровненой, чем build. Она упрощает работу с build, так как
заранее имеет заготовленные инструменты (например, GeneratorForAnnotation<T>), чтобы не работать с build напрямую. Analyzer - пакет, который представляет
весь код как структуру, а не строку текста (как видит компьютер изначально). Он использует Abstract Syntax Tree (AST) для представления всего кода
как структуры, с которой потом легко работать source_gen для поиска нужных классов. В Dart также присутствуют мощные директивы part и part of,
которые говорят компилятору о том, что они являются цельным файлом, несмотря на то, что находятся в разных файлах. Это помогает обращаться и
использовать даже приватные методы класса.

3. How [`Builder`]s are registered and used in a [Dart] project?
Builder регистируется в build.yaml, где указывается название билдера, какие файлы использует на входе, какие генерирует на выходе, куда он сохраняет
код и др. Таким образом мы регистируем билдер, который после будет запущен build_runner'ом. Builder'ы проходят по всем файлам, которые удовлетворяют
условию, ищут классы, с которыми они работают и выполняют свою работу. Builder'ы не всегда генерируют код, они могут использовать и для других целей
(например, сбор информации), для генерации используются отдельный тип builder'ов - Generator. Интересным является то, что иногда код, сгенерированный
одним билдером может быть подан на вход другому билдеру. 

4. What is the purpose of [`analyzer`] and [`source_gen`] packages? Why do we need them for code generation in [Dart]?
Ответ на этот вопрос был дан в ответе на вопрос 2. Добавить можно только то, что analyzer нужен в кодогенерации, так как он работает рука об руку
с source_gen. source_gen упрощает работу с build, в том числе упрощая поиск нужных классов. Но именно analyzer помогает преставлять код как структуру
с помощью AST. Иначе пришлось бы искать по ключевым словам, которые не всегда дают верные результаты.

5. What are annotations in [Dart]? How are custom annotations created? How they can be used and why?
Аннатоции в Dart по факту являются константными конструкторами. Но они предоставляют метаданные, которые дают важную информацию для инструментов в роде
source_gen, не влияя на исполнение кода. Они могут принимать параметры или просто помечать классы для того, чтобы после инструменты обрабатывали
их. Они имеют решающее значение в кодогенерации, так как помогают помечать классы, для которых нужно сгенерировать код. В Dart есть встроенные
аннотации, такие как @override, а также можно создавать свои собственные. Аннатоции ставятся перед классом и начинаются с @.

6. Which are good practices of code generation in [Dart] ecosystem?
Хорошие практики кодогенерации включают в себя:
1. Не комитить сгенерированные файлы (обычно), так как они тянут много кода, который и так будет сгенерирован после. Исключением является написание
библиотек, чтобы не заставлять пользователя запускать генераторы вручную.
2. Соблюдать детерминированность. Кодогенерация должна давать всегда один и тот же результат вне зависимости от того, когда именно она запущена.
3. Соблюдать форматирование в сгенерированном коде.
4. Не изменять сгенерированный код (это бессмысленно, ведь при следующем запуске билдера код будет перезаписан).
