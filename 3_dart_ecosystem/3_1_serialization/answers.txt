1. What is serialization? Why is it used? What problems does it solve?
Сериализация – это процесс перевода какой-либо структуры данных из памяти (например, объекта класса в Dart) в последовательность байтов или текста.
Есть ещё и десереализация - обратный процесс сериализации, то есть перевод последовательности байтов или текста в структуру данных.
Основная её цель – хранение данных в удобной форме. Эта форма может быть удобна как для чтения человеком (например, JSON), так и для чтения программой. Сериализация решает проблему необходимости надёжного хранения и перемещения данных. Мы переводим данные в нужный формат и можем быть уверены, что они не повредятся и будут иметь корректный формат. Если же формат будет нарушен, программа сможет обнаружить это и сообщить об ошибке.

2. How serialization is represented in [Dart]? Describe and explain core abstractions.
В Dart сериализация представлена, в первую очередь, с помощью встроенной библиотеки dart:convert. В данной библиотеке реализованы базовые функции для работы с различными форматами. Это может быть как перевод кодировки, так и кодирование/декодирование JSON (например, перевод в Map и наоборот). Использование этой библиотеки очень удобно и помогает не тратить время на написание этой логики самостоятельно.

Также существует большое количество сторонних библиотек для работы с более специфичными форматами. Например, для YAML существует библиотека yaml (которая выполняет функцию парсера) и yaml_writer (для записи в этот формат). Аналогично, существуют библиотеки и для других форматов, вроде TOML.

3. What are good practices when implementing a serializable type? Why?
Существует несколько хороших практик при реализации сериализуемых типов.

Реализация методов toJSON и fromJSON. Является хорошей практикой писать для класса одноимённые функции toJSON() и fromJSON(). Это общепринятый формат, и реализовать такую логику в этих методах очень удобно, особенно учитывая, что JSON – один из самых популярных форматов для передачи данных.

Использование генерации кода. Ещё одной хорошей практикой является генерация кода. Существует библиотека json_annotation, которая позволяет удобным образом генерировать код для парсинга и сериализации данных на основе уже написанных алгоритмов. Это особенно удобно, когда мы имеем дело с большими JSON-файлами, ручная сериализация которых представляет собой трудоёмкий процесс. Задача не столько сложная, сколько муторная и долгая, так как требует написания большого количества однотипного кода. Генерация кода позволяет гарантировать, что в этой рутинной задаче не будет допущено ошибок.

Использование JsonConverter. Однако для некоторых нужд требуется более чёткое поведение и контроль над тем, как сериализуются данные и какие типы они имеют. Для этого в той же библиотеке json_annotation существует JsonConverter. Его использование также является хорошей практикой, когда нам нужно внедрить специфичную логику для определённых типов.

4. How code generation can help with serialization? When is it better to use it? When not?
Генерация кода очень сильно помогает в сериализации. С помощью библиотеки json_annotation и аннотации @JsonSerializable мы можем генерировать код очень быстро и просто. Это позволяет избежать написания большого количества однотипного кода и избавляет разработчика от муторной и долгой работы.
Использовать кодогенерацию лучше всего тогда, когда мы работаем с большими JSON-файлами. Разобраться в них бывает сложно, и при ручном написании парсеров очень легко запутаться и допустить ошибку.

Когда лучше не использовать её? 
Маленькие файлы. Нет большого смысла использовать кодогенерацию для маленьких файлов. Зачастую легче и быстрее будет написать реализацию самостоятельно.
Большое количество специфичных типов. Если наш JSON содержит много нестандартных типов данных (то есть не String, int и т.п., а типы из других библиотек), которые должны быть представлены в какой-то конкретной форме, использовать генерацию может быть сложнее. В таком случае нам придётся писать очень большое количество конвертеров (JsonConverter). Эта задача может оказаться сложнее, чем написать всю реализацию с нуля самостоятельно, так как при ручной реализации мы сможем лучше контролировать поведение процесса сериализации.