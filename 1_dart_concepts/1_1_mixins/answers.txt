1. Why do you need to extend classes? Name some examples.
Расширение классов - это одно из важнейших действий в любом ООП-языке (в том числе и в Dart). Хотя бы потому, что оно - часть нескольких принципов ООП - наследование (inheritance), полиморфизм (polymorphism). Расширение классов очень полезно для того, чтобы избежать дублирования кода (DRY принцип). Если какие-то классы должны "иметь" определённое поведение или свойства, то вместо того, чтобы писать для каждого класса для одинакового метода, мы можем создать родительских класс, описать этот метод в нём и все классы-дети будут также его иметь. Но если какому-то классу-ребёнку нужно, чтобы данный метод выполнялся иначе, то мы можем переписать этот метод или же дополнить его другим поведением, однако сохранить выполнение кода класса-родителя. Также Dart позволяет гарантировать, что все наследники класса могут участвовать в проверках на класс их родителя. Что это значит? Это значит, что если у нас есть часть кода, где только определённый класс может участвовать, и он является классом-родителем для других классов, то классы-дети также смогут участвовать в этой части кода. Расширение классов также полезно, чтобы создавать иерахрию классов, где каждый класс-ребёнок может прямым образом взаимодействовать с классом-родителем (через super).
В целом, расширение классов является очень полезным средством, находящим множество применений и являющимся неотъемлимой частью любого ООП-языка.

2. Can extension be private? Unnamed? Generic?
Да, расширение может быть приватным и выполняться только в файле, где описано. Оно также может быть и безымянным, но тут стоит сделать оговорку, что если в классе имеются 2 расширения, добавляющие один и тот же метод, то может вызваться конфликт, так что стоит быть с этим аккуратней. Также мы не можем вызвать неназванные расширения отдельно из библиотеки (через show), в отличие от названных, поэтому нужно будет импортировать всю библиотеку, чтобы получить к ним доступ. Универсальными расширения также могут быть и расширять класс, например List<T>. Однако стоит учесть, что код расширения должен гарантировать, что для любого типа, который туда "придёт", код будет корректным.

3. How to resolve naming conflicts when multiple extensions define the same methods?
Данный конфликт легко решается, делая метод именованным. По итогу вызов метода будет выглядить таким образом: НазваниеРасширения(объектРасширяемогоКласса).Метод(). Это позволяет управлять тем, какой из методов будет использоваться. Также решение проблемы может быть другим: использование hide/show для одного из метода из библиотеки/файла. Например, мы можем не импортировать метод из библиотеки файла через hide. Также данный конфликт решается при добавлении ключевого слова as в импорте. Тогда мы можем обращаться напрямую к имени библиотеки, которое дали через as, затем так, как и при именованном методе, то есть ИмяБиблиотекиЧерезAs.объектРасширяемогоКласса.Метод().

4. What is reasoning behind mixins? Why would you need them? Provide some examples.
Миксины представляют собой определённое поведение, которое может использовать класс. В отличие от наследования, миксины не являются родителями класса, они просто предоставляют поведение, описанное в них. Данное поведение может принимать любой класс, не обязательно принадлежащий определённой иерархии. Однако, если нужно это контролировать, тогда можно использовать ключевое слово on, которое заставляет любой класс, который принимает поведение миксина, быть подклассом класса, который указан в on. Также класс может принимать любое количество миксинов и наследовать всё поведение из них. Миксины могут предоставлять асбтрактные методы, заставляя класс реализовать его самостоятельно. Миксины нужны для того, чтобы внедрять определённое поведение у нескольких классов одновременно для избежания дублирования кода (DRY) и повышения его читабельности. Миксины также могут использовать интерфейсы, однако реализацию их берёт на себя не миксин, а класс, который его использует. Но нужно понимать, что миксины не могут создавать свои конструкторы, а также класс не может использовать поля, определённые в миксине, в своём конструкторе. Для этого и используется абстракции в миксинах. Мы также может выполнять проверки на все элементам, которые наследовали миксин. Например, если нужно, чтобы только определённые классы (которые наследуют в миксин) прошли ту или иную проверку/поучаствовали в той или иной операции, то можно использовать метод .whereType<ИмяМиксина>() и это сработает.

5. Can you add static methods and/or fields to mixins?
Да, это можно сделать. Однако стоит иметь в виду, что классы, использующие миксины НЕ принимают статические переменные и методы. Для того, чтобы обращаться к статическим методам и полям нужно обращаться к самому миксину, например ИмяМиксина.стаическийМетод(). Происходит это потому, что миксин имеет своё пространство имён, в котором могут существовать статические методы и поля.

6. `class`, `mixin`, or `mixin class`? What are differences? When to use each one?
Миксин, класс и миксин класс - три разных понятия в Dart. Разница между ними заключается в том, что применяются они для разных целей. Миксины, как было сказано ранее, позволяют определять поведение для разных объектов без наследования. Классы позволяют делать это же, однако наследуюсь, позволяя обращаться к родительскому классу, участвовать в проверках родителя и т.п., что также было описано выше. Когда мы говорим про mixin class, то это сущность, которую можно использовать и как миксин (с with), и как класс (с extends). Миксин класс, как и другие классы могут иметь конструкторы, однако они не наследуются при использовании with. 