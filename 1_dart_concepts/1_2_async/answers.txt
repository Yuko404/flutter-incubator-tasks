1.What is multitasking? Why it exists? How is it used for solving CPU-bound and I/O-bound problems?

Многозадочность - это способность ОС выполнять несколько задач одновременно. Существует она для улучшения пользовательского опыта, повышения эффективности работы ОС и снижения нагрузки на неё. При создании приложения особенно важна многозадачность, ведь если UI "застынет", пока будет выполнять другая задача, пользователь не захочет дальше использовать приложение. Говоря про многозадачность, стоит отметить, что существует несколько способов её достигнуть:
1. Параллелизм. Достигается он тем, что ОС выполняет несколько задач одновременно. Например, мы можем использовать разные ядра для выполнения разных задач. Как только задача будет выполнена, мы сможем уже сообщить об этом, не дожидаясь выполнения других задач. Итого, мы очень сильно выигрываем во времени по сравнению с тем, как бы задачи выполнялись последовательно (синхронно). Бывает, программы не могут использовать несколько ядер для работы или же им столько мощностей не требуется, поэтому мы никак не можем ускорить их работу, а значит остальные ядра свободны и мы можем дать им другие задачи для выполнения.
2. Конкурентность. Достигается она тем, что ОС переключается между задачами. Если мы ждём, пока выполнится задача (например, пользовательский ввод), система ничего не выполняет никаких задач. Поэтому мы можем выполнять другие задачи, а как пользователь введёт данные, продолжить работу программы. Но важно помнить, что при асинхронности у нас один поток и мы не можем выполнять задачи параллельно, как при параллелизме.
В Dart существует и параллелизм (с помощью Изолятов, сам по себе Dart - однопоточный язык) и конкурентность (с помощью async, await, Future, Stream и т.п.).

2.What is preemptive multitasking? What is cooperative multitasking? Which one is used in [Dart]?

Существует два вида многозадачности: вытесняющая (preemptive) и кооперативная (cooperative). При вытесняющей многозадачности планировщик задач принудительно приостанавливает выполнение текущей задачи для того, чтобы запустить следующую, которая уже готова для исполнения. Как раз таки такая приостановка называется вытеснением (отсюда и название). Будет ли вытесняться задача может быть определено по-разному (например, через приоритет задачи (если у задачи выше приоритет, она вытеснит задачу с более низкими), таймер (по истечению таймера, задача сразу запустится) и т.п.). Кооперативная задача же имеет планировщик задач, который сам распределяет, какая задача будет выполнена следующей. Задачи не приостанавливаются, а определяется их очередь выполнения. Именно кооперативная многозадачность и присутствует в Dart. Достигается она с помощью механизма Event Loop, который имеет две очереди - Microtasks queue и Event Queue. Сначала выполняются все микрозадачи из Microtasks queue, после же начинается выполнение задач из Event Queue. Если во время выполнения задач из Event Queue, появилась задача в Microtasks queue, то следующей в очереди будет микрозадача из Microtasks queue. Сам механизм Event Loop работает только для асинхронных задач, синхронные же задачи всегда выполняются до асинхронных. 

3.What is asynchronous programming and when do we need it? How is it represented in [Dart]?

Асинхронное программирование - это подход, при котором программа не приостанавливает работу во время долгих задач (операции, которые не являются часть программы, например, обращение к серверу, ввод пользователя, ожидание и т.п.), а передают управление другим задачам. Асинхронное программирование нужно для того, чтобы грамотно распределять время работы программы и улучшить пользовательский опыт. Например, нам нужно сделать запрос к серверу, получить ответ и в то же время пользователь хочет далее исследовать приложение. С помощью асинхронного программирования мы можем сделать запрос к серверу и, не дожидаясь ответа, отрисовать пользователю UI. А когда ответ придёт сохранить его и сообщить пользователю о том, что он может вернуться к предыдущей странице, ведь задача выполнена. В Dart асинхронное программирование представлено с помощью ключевых слов async, await, а также классов Future, Stream и другими, которые позволяют работать с ними. async помечает функцию, как асинхронную, для того, чтобы выполнить await. await же приостанавливает выполнения операции и передаёт управление Event loop, а когда ответ придёт, позволяет продолжить выполнение функции. Future же можно назвать "обещанием" того, что операция будет выполнена (например, через время, или как придёт ответ). А Stream является очередью таких "обещаний", то есть потоком. С помощью всех этих инструментов мы можем реализовывать асинхронное программирование в Dart.

4.What is a [`Stream`] and how this abstraction is useful? Give some real-world examples of using it.

Stream - это поток "обещаний". В отличие от Future, который даёт одно "обещание", Stream представляет собой ряд таких "обещаний". Как только придёт результат в Stream мы можем его обработать и передать управление другим функциям, дожидаясь следующего. Как придёт следующее обещание, мы также его обработаем и передадим управление. Так можно повторять по кругу, пока мы перестанем слушать поток или он не будет закрыт. Stream очень полезен, ведь во множестве операций и задач нам нужно получать несколько частей информации и обрабатывать их, ведь это намного быстрее, чем получить огромную часть данных и обработать её за раз. Например, при получении большого файла. Пользователь в первом случае получит ответ практически сразу, как придёт последняя часть информации, а во втором будет ждать обработки всей информации. Также Stream критически нужен при обработке сообщений. Мы можем начать слушать поток, а когда получим сообщение, отправить сообщение в ответ или запустить какую-то операцию. Такая модель имеет место при работе с сервером и запросами от него.

5.What is a [`Timer`] and how this abstraction is useful? Give some real-world examples of using it.

Таймер, исходя из названия, представляет собой обратный отсчёт. Когда обратный отсчёт закончится, выполнится функция, для которой был вызван таймер. Таймер можно использовать как для однократного запуска, так и для периодического. Полезен таймер может быть во многих областях, где нужно выполнять операцию через время. Например, хорошим применением таймера будет использование его для Debounced техники, которая помогает уменьшить количество вызовов функции, или же при периодической проверке сервера для того, чтобы обновлять информацию на стороне приложения.

6.How does [Dart] handles multiple [`Isolate`]s? How do they communicate with each other? How to share memory between [`Isolate`]s?

Изоляты в Dart позволяют организовывать тот самый параллелизм. Сама по себе программа на Dart выполняется в главном изоляте. Из него мы можем создать ещё один Изолят, в который передадим функцию для выполнения. Мы можем создавать несколько изолятов в передавать им функции, а потом дождаться выполнения всех и получить ответы, например, с помощью <Future>[] и Future.wait. Изоляты в Dart можно создавать несколькими способами: Isolate.run, Isolate.spawn, compute (только в Flutter) и т.п. Isolate.run() - простой способ создания Изолята, который необходим для быстрого создания кратковременного изолята для того, что параллельно выполнить одну функцию. Isolate.spawn() - уже более продвинутый уровень создания Изолятов. Ничего автоматически здесь не происходит (ни создание соединения между изолятами, ни его удаление). Вручную нужно настраивать порты (receivePort, sendPort), удаление Изолята и т.п. Однако такой изолят более гибкий и долгоживущий. Такой изолят можно использовать для того, чтобы запускать несколько функций параллельно (после завершения одной, запустить другую и т.п.). Это уже более гибкий подход, но нуждающийся в особой реализации. compute() - функция из пакета Flutter, которая аналогична  Isolate.run, однако более предпочтительно для Flutter-приложений. Она более безопасна для выполнения, проще в использовании и обрабатывается хорошо в вебе. Isolate.run() же обладает чуть большей гибкость. В изолятах память не делится между друг другом. У каждого Изолята своя память, общая память отсутствует. Это помогает решать проблемы с гонками данных, утечками и т.п., однако нуждается в создании соединений (через порты) для того, чтобы передавать данные между изолята.

7.How `Isolate.spawn` and `Isolate.spawnUri` are different?

Как было описано выше. Isolate.spawn() - продвинутый уровень создания Изолятов, где всё нужно настраивать вручную (порты, удаление Изолята и т.п.). При таком создании изолят создаётся в одной группе с изолятом, из которого был запущен, а также использует тот же самый исполняемый вход. В качестве параметра указывается точка входа изолята. Одна группа Изолятов позволяет передавать большую вариативность данных, нежели в разных группах. Isolate.spawnUri() создаёт изолят, код которого записан в отдельном файле (Uri - ссылка на этот файл). Такой Изолят создаёт новую группу и точкой входа его является main-функция исполняемого файла.

8.What is concurrency and how is it different from parallelism? How both are represented in [Dart]?
Подробно про конкурентность и параллелизм я ответил и расписал в вопросе 1.
